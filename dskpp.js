/*
This module is used by the authenticator app on mobile devices to provision symmetric keys.
*/

const request = require('request');
const bodyParser = require('body-parser');
const url = require('url');
const cryptoModule = require('./crypto_module.js');
const xml2js = require('xml2js');
const xmlParser = new xml2js.Parser({"explicitArray":false});
const qr = require('qr-image');
const oath_db = require("./database.js");

function generateAuthData(key, clientId, hostname, clientNonce, serverNonce) {
	//AC->ClientID||URL_S||R_C||R_S
	var clientIdBuffer = new Buffer(clientId, 'utf8');
	var serverUrlBuffer = new Buffer(hostname, 'utf8');
	var prfBuffer = Buffer.concat([clientIdBuffer,serverUrlBuffer,clientNonce,serverNonce],clientIdBuffer.length+serverUrlBuffer.length+clientNonce.length+serverNonce.length);
	return cryptoModule.dskppPrf(key, prfBuffer, 32);
}

/*
The payload of the call determines the action.
The service handles XML documents with the XML root tag either 
dskpp:KeyProvClientHello or dskpp:KeyProvClientNonce
*/
module.exports = function(req, res) {
	const hostname = req.hostname;
	if (req.is("application/dskpp+xml")) {
		var msg = req.body.toString('utf8');
		// Parse the XML body
		req.body = xmlParser.parseString(msg, function(err, result) {
			if (err) {
				// Body XML cannot be parsed. Return 400 bad request.
				res.sendStatus(400);
				return;
			}
			req.body = result;
			if (req.body["dskpp:KeyProvClientHello"]) {
				// Called to initiate the key provisioning sequence.
				if (req.body["dskpp:KeyProvClientHello"]["dskpp:DeviceIdentifierData"]["dskpp:DeviceId"]) {
					var deviceManufacturer = req.body["dskpp:KeyProvClientHello"]["dskpp:DeviceIdentifierData"]["dskpp:DeviceId"]["pskc:Manufacturer"];
					var deviceSerialNo = req.body["dskpp:KeyProvClientHello"]["dskpp:DeviceIdentifierData"]["dskpp:DeviceId"]["pskc:SerialNo"];
				} else {
					// Device id is missing. Return 400 bad request.
					res.sendStatus(400);
					return;
				}
				// Generate server nonce
				const serverNonce = cryptoModule.random(32).toString('base64');
				// Insert the key provisioning session object to the database
				oath_db.insert({'type':'session','timestamp':Date.now()},function(error,body){
					if (!error && body.ok) {
						// Get the XML that will be rendered.
						res.render(__dirname + "/views/keyprov_server_hello",{"sessionId":body.id,"serverNonce":serverNonce},function(err, xml){
							// Update the session with the rendered XML. Concatenated XML messages passed between the client and the server are later used for verification.
							oath_db.insert({'type':'session','r_s':serverNonce,'timestamp':Date.now(),'ip_address':req.ip,'messages':msg+xml,'device_manufacturer':deviceManufacturer,'device_serial_no':deviceSerialNo,'_rev':body.rev,'_id':body.id}, function(err) {
								if (!err) {
									// Render the server hello XML.
									res.contentType("application/dskpp+xml");
									res.send(xml);
								} else {
									res.sendStatus(500);
								}
							});
						});
					} else {
						res.sendStatus(500);
					}
				});
			} else if (req.body["dskpp:KeyProvClientNonce"]) {
				// Called after the client receives the server hello message and generates the client nonce.
				var sessionId = req.body["dskpp:KeyProvClientNonce"]["$"]["SessionID"];
				// Client nonce encrypted using the SSL connection's public key.
				var encryptedClientNonce = req.body["dskpp:KeyProvClientNonce"]["dskpp:EncryptedNonce"];
				// Authentication data generated by the client from the Auth Code (AC) given to the user in a separate channel (e.g. QR code).
				var authData = req.body["dskpp:KeyProvClientNonce"]["dskpp:AuthenticationData"];
				// Get the session object created in response to client hello request.
				oath_db.get(sessionId, function(error, body) {
					if (!error && body.type == 'session' && body.r_s) {
						var deviceManufacturer = body.device_manufacturer;
						var deviceSerialNo = body.device_serial_no;
						var rev = body._rev;
						var messages = body.messages + msg;
						const serverNonce = new Buffer(body.r_s, 'base64');
						var nonceBuffer = new Buffer(encryptedClientNonce, 'base64');
						if (authData) {
							// The client for whom to generate the key.
							const clientId = authData["dskpp:ClientID"];
							// The number of PRF iterations to run when generating the key. Must be at least 100000.
							const iterationCount = parseInt(authData["dskpp:AuthenticationCodeMac"]["dskpp:IterationCount"]);
							// MAC generated from the derived key, client ID, hostname of the server and the client and server nonces.
							const mac = new Buffer(authData["dskpp:AuthenticationCodeMac"]["dskpp:Mac"], 'base64');
							// Get the client from the database.
							oath_db.get(clientId, function(err, client) {
								if (err || client.type != 'client') {
									// Client not found.
									res.sendStatus(404);
									return;
								}
								const callbackUrl = client.reg_callback_url;
								var appId = client.app_id;
								// Decrypt the client nonce using the server SSL cert's private key.
								cryptoModule.decrypt(nonceBuffer, function(err, clientNonce) {
									if (err) {
										res.sendStatus(500);
										return;
									}
									clientNonce = new Buffer(clientNonce, 'binary');
									// Derive a key from the server's hostname, user's password and client nonce using iterationCount iterations.
									cryptoModule.pbkdf2(hostname, client.password, clientNonce, iterationCount, function(err, derivedKey) {
										if (err) {
											res.sendStatus(500);
											return;
										}
										// Generate a MAC from the derived key, client id, server's hostname and the client and server nonces.
										var authDataMac = generateAuthData(derivedKey, clientId, hostname, clientNonce, serverNonce);
										// Check that the MAC matches the one received in the XML.
										if (mac.equals(authDataMac)) {
											var keyGenBuffer = new Buffer("Key generation", "utf8");
											// Get the server SSL cert's public key.
											cryptoModule.serverPublicKey(hostname, function(err, serverPublicKey) {
												// Generate a 64-byte long provisioning key using the DSKPP pseudo random function PRF.
												var kProv = cryptoModule.dskppPrf(clientNonce, Buffer.concat([keyGenBuffer, serverPublicKey, serverNonce], keyGenBuffer.length+serverPublicKey.length+serverNonce.length), 64);
												// The first half of the provisioning key is a MAC.
												var kMac = kProv.slice(0, kProv.length/2);
												// The second half is the symmetric key to be used when generating one-time passwords (OTP) at authentication.
												var kToken = kProv.slice(kProv.length/2);
												// Function to save the key once the MAC has been verified.
												function saveKey(keyObject) {
													// Insert the key object in the database.
													oath_db.insert(keyObject, function(err, body) {
														if (err) {
															res.sendStatus(500);
															return;
														}
														// Delete the client temporary password. Another password will be generated when provisioning a new key.
														client.password = null;
														oath_db.insert(client);
														var keyId = body.id;
														// Generate a SHA256 checksum of the XML messages passed between the server and the client.
														var msgHash = cryptoModule.sha256(messages);
														var msgBuf = new Buffer("MAC 1 computation", "utf8");
														// Generate a MAC from the messages checksum.
														var msgMac = cryptoModule.dskppPrf(kMac, Buffer.concat([msgBuf,msgHash], msgBuf.length+msgHash.length), msgHash.length);
														// Send server finished message to the client.
														res.contentType("application/dskpp+xml");
														res.render(__dirname + "/views/keyprov_server_finished",{"sessionId":sessionId,"keyId":keyId,"mac":msgMac.toString("base64")});
														if (callbackUrl && appId) {
															// Notify the consumer app that the key provisioning finished.
															// Get the app associated with the app ID.
															oath_db.get(appId, function(err, app) {
																if (!err && app.secret) {
																	var data = {
																		"client_id": clientId,
																		"status": "success",
																		"type": "registration"
																	};
																	var signatureBase = callbackUrl+JSON.stringify(data);
																	var key = new Buffer(app.secret);
																	// Sign the callback URL and the JSON payload with the app secret.
																	// The consumer app should verify the signature to ensure the callback notification is genuine.
																	var signature = cryptoModule.hmacSha256(key, signatureBase).toString('hex');
																	// Generate the callback request.
																	var callbackRequest = {
																		"url": callbackUrl,
																		"method": "POST",
																		"form": data,
																		"headers": {
																			"x-verid-signature": signature
																		}
																	};
																	// Send the callback request.
																	console.log("Send registration callback for client "+clientId+" to "+callbackUrl);
																	request(callbackRequest);
																}
															});
														}
													});
													// Delete the session from the database.
													oath_db.destroy(sessionId, rev);
												}
												// Get the keys registered for the device.
												oath_db.view("keys","by_device",{"keys":[deviceSerialNo]}, function(err, result) {
													var keyObject = {'type':'key','client_id':clientId,'key':kToken.toString('hex'),'device_manufacturer':deviceManufacturer,'device_serial_no':deviceSerialNo};
													if (!err && result.rows.length > 0) {
														for (i in result.rows) {
															var doc = result.rows[i];
															if (doc.value.client_id == clientId) {
																// The client already has a key registered for that device.
																// Get the key object from the database.
																oath_db.get(doc.id, function(err, key) {
																	if (!err) {
																		// Update the key object with the new value.
																		key.key = kToken.toString('hex');
																		saveKey(key);
																	} else {
																		saveKey(keyObject);
																	}
																});
																return;
															}
														}
													}
													// Insert the key object in the database.
													saveKey(keyObject);
												});
											});										
										} else {
											// The generated MAC and the received MAC do not match.
											res.sendStatus(400);
										}
									});
								});							
							});
						} else {
							// Missing auth data. Return 400 bad request.
							res.sendStatus(400);
						}
					} else {
						// Session not found. Return 404.
						res.sendStatus(404);
					}
				});
			} else {
				// The root element of the XML may be either dskpp:KeyProvClientHello
				// or dskpp:KeyProvClientNonce
				res.sendStatus(400);
			}
		});
	} else {
		// The MIME type must be application/dskpp+xml
		res.sendStatus(400);
	}
}